// import axios from 'axios';
// import dotenv from 'dotenv';
// import fs from 'fs';
// import path from 'path';

// const DEFAULT_MODEL = 'gemini-1.5-pro-latest';

// // Enhanced environment loading
// const loadEnvironment = () => {
//   // Try loading from different possible .env locations
//   const envPaths = ['.env', '../.env', '../../.env'];
  
//   for (const envPath of envPaths) {
//     if (fs.existsSync(envPath)) {
//       console.log(`Loading environment from ${envPath}`);
//       dotenv.config({ path: envPath });
//       break;
//     }
//   }
  
//   // Always call the default config as fallback
//   dotenv.config();
// };

// // Load environment variables
// loadEnvironment();

// // Check if we're in production mode
// const isProduction = process.env.NODE_ENV === 'production';
// // Check if we should force local analysis (bypass API) regardless of environment
// const forceLocalAnalysis = process.env.FORCE_LOCAL_ANALYSIS === 'true';

// if (isProduction) {
//   console.log('ðŸ”’ Running in PRODUCTION mode - Using local analysis by default');
// }

// if (forceLocalAnalysis) {
//   console.log('ðŸ”’ FORCE_LOCAL_ANALYSIS is enabled - All AI API calls will be bypassed');
// }

// // Helper function to create a default response
// const createDefaultResponse = (message) => {
//   return {
//     fullAnalysis: message,
//     category: 'General activity',
//     patterns: 'No unusual patterns detected',
//     riskLevel: 'MEDIUM'  // Changed from UNKNOWN to MEDIUM
//   };
// };

// const API_KEYS = [
//   process.env.GEMINI_API_KEY1,
//   process.env.GEMINI_API_KEY2,
//   process.env.GEMINI_API_KEY3,
//   process.env.GEMINI_API_KEY4, 
//   process.env.GEMINI_API_KEY5, 
//   process.env.GEMINI_API_KEY6, 
// ];

// // Create a key status tracking object
// const apiKeyStatus = API_KEYS.map((key, index) => ({
//   key: key ? key.substring(0, 5) + '...' : 'undefined',
//   index,
//   quotaExceeded: false,
//   lastUsed: null
// }));

// // Add this function to visualize API key status
// const logApiKeyStatus = () => {
//   console.log('\n=== API Key Status ===');
//   apiKeyStatus.forEach(key => {
//     const status = key.quotaExceeded ? 
//       'QUOTA EXCEEDED' : 
//       'AVAILABLE';
//     const lastUsed = key.lastUsed ? 
//       `Last used: ${key.lastUsed.toLocaleTimeString()}` : 
//       'Not used yet';
//     console.log(`Key ${key.index + 1} (${key.key}): ${status} - ${lastUsed}`);
//   });
//   console.log('=====================\n');
// };

// let currentKeyIndex = 0;

// // Function to perform local activity analysis without using the API
// const performLocalActivityAnalysis = (activityData) => {
//   const { role, action, route } = activityData;
  
//   // Simple rule-based analysis logic
//   let riskLevel = 'MEDIUM';
//   let category = 'General Activity';
  
//   // Determine category based on route
//   if (route.includes('/admin')) {
//     category = 'Admin Access';
//   } else if (route.includes('/user')) {
//     category = 'User Management';
//   } else if (route.includes('/data') || route.includes('/report')) {
//     category = 'Data Access';
//   } else if (route.includes('/settings')) {
//     category = 'System Configuration';
//   }
  
//   // Determine risk level based on role and action
//   if (role === 'Admin' || role === 'Administrator') {
//     // Admin actions are generally lower risk unless destructive
//     if (action === 'DELETE' || action === 'MODIFY') {
//       riskLevel = 'MEDIUM';
//     } else {
//       riskLevel = 'LOW';
//     }
//   } else if (role === 'Guest' || role === 'Anonymous') {
//     // Guest actions are generally higher risk
//     if (action === 'VIEW' || action === 'READ') {
//       riskLevel = 'MEDIUM';
//     } else {
//       riskLevel = 'HIGH';
//     }
//   } else {
//     // Regular users
//     if (action === 'DELETE') {
//       riskLevel = 'HIGH';
//     } else if (action === 'MODIFY' || action === 'UPDATE') {
//       riskLevel = 'MEDIUM';
//     } else {
//       riskLevel = 'LOW';
//     }
//   }
  
//   // Special high-risk cases
//   if (route.includes('/admin') && role !== 'Admin' && role !== 'Administrator') {
//     riskLevel = 'HIGH';
//   }
  
//   return {
//     fullAnalysis: `Local analysis performed for ${role} performing ${action} on ${route}. Risk assessed as ${riskLevel}.`,
//     category,
//     patterns: 'Analysis performed locally without AI assistance',
//     riskLevel,
//     isLocalAnalysis: true
//   };
// };

// export const analyzeActivityWithAI = async (activityData, model = DEFAULT_MODEL, forceLocal = false) => {
//   try {
//     const { name, role, department, route, action, description } = activityData;

//     // Validate that all required fields are present
//     if (!name || !role || !department || !route || !action || !description) {
//       console.error('AI analysis error: Missing required fields');
//       return createDefaultResponse('AI analysis unavailable - missing required fields');
//     }
    
//     // Skip API calls if we're in production, forcing local analysis, or if the override parameter is true
//     if (isProduction || forceLocalAnalysis || forceLocal) {
//       console.log('ðŸ”’ Using local activity analysis (API bypassed)');
//       return performLocalActivityAnalysis(activityData);
//     }

//     // Create a structured prompt for the AI to analyze
//     const prompt = `
//     You are a security and user behavior analysis expert. Analyze this user activity:
  
//     User: ${name}
//     Role: ${role}
//     Department: ${department}
//     Route: ${route}
//     Action: ${action}
//     Description: ${description}
  
//     Provide detailed analysis about:
//     1. Categorization of this activity (e.g., Data Access, User Management, System Configuration)
//     2. Any unusual patterns or behaviors
//     3. Risk assessment: LOW, MEDIUM, or HIGH based on:
//        - User role and permissions (e.g., "Guest" performing "DELETE" is HIGH risk)
//        - Sensitivity of the route or action (e.g., accessing "/admin/settings" is HIGH risk)
//        - Unusual patterns or behaviors (e.g., repeated failed login attempts)
  
//     Examples:
//     - A "Guest" user attempting to "DELETE" sensitive data is HIGH risk.
//     - An "Admin" user viewing a dashboard is LOW risk.
//     - A "Manager" updating user permissions is MEDIUM risk.
  
//     Format your response as JSON:
//     {
//       "fullAnalysis": "detailed explanation of your overall analysis",
//       "category": "brief category name",
//       "patterns": "description of any unusual patterns or 'No unusual patterns detected'",
//       "riskLevel": "LOW", "MEDIUM", or "HIGH"
//     }
//   `;
//     while (currentKeyIndex < API_KEYS.length) {
//       const GEMINI_API_KEY = API_KEYS[currentKeyIndex];
//       const GEMINI_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent`;

//       // Update last used timestamp
//       apiKeyStatus[currentKeyIndex].lastUsed = new Date();
      
//       console.log(`Using API Key ${currentKeyIndex + 1}: ${GEMINI_API_KEY?.substring(0, 5)}...`);

//       try {
//         // Skip the API call if the key is undefined or empty
//         if (!GEMINI_API_KEY) {
//           throw new Error('API key is undefined or empty');
//         }
        
//         const response = await axios.post(
//           `${GEMINI_API_URL}?key=${GEMINI_API_KEY}`,
//           {
//             contents: [
//               {
//                 parts: [
//                   { text: prompt }
//                 ]
//               }
//             ],
//             generationConfig: {
//               temperature: 0.2,
//               maxOutputTokens: 800
//             }
//           },
//           {
//             headers: {
//               'Content-Type': 'application/json'
//             },
//             timeout: 15000 // 15 seconds timeout
//           }
//         );

//         // Extract and parse the JSON response from the AI
//         const rawText = response.data?.candidates?.[0]?.content?.parts?.[0]?.text;

//         if (!rawText) {
//           throw new Error('Empty or invalid response from AI API');
//         }

//         let parsedResponse;
//         try {
//           parsedResponse = JSON.parse(rawText);
//         } catch (parseError) {
//           const jsonMatch = rawText.match(/\{[\s\S]*\}/);
//           if (!jsonMatch) {
//             throw new Error('No valid JSON found in AI response');
//           }
//           parsedResponse = JSON.parse(jsonMatch[0]);
//         }

//         if (!parsedResponse.fullAnalysis || !parsedResponse.category || 
//             !parsedResponse.patterns || !parsedResponse.riskLevel) {
//           throw new Error('Incomplete analysis data from AI');
//         }

//         parsedResponse.riskLevel = parsedResponse.riskLevel.toUpperCase();
//         if (!['LOW', 'MEDIUM', 'HIGH'].includes(parsedResponse.riskLevel)) {
//           parsedResponse.riskLevel = 'MEDIUM';
//         }

//         console.log('Successfully received and parsed AI response');
//         return parsedResponse;

//       } catch (error) {
//         if (error.response && error.response.status === 429) {
//           console.warn(`âš ï¸ QUOTA EXCEEDED for API Key ${currentKeyIndex + 1}`);
//           // Mark this key as exceeded
//           apiKeyStatus[currentKeyIndex].quotaExceeded = true;
//           currentKeyIndex++;
//           // Log the updated status of all keys
//           logApiKeyStatus();
//         } else {
//           console.error('AI analysis error:', error.message);
//           // If we encounter a non-quota error, fall back to local analysis
//           console.log('Falling back to local activity analysis');
//           return performLocalActivityAnalysis(activityData);
//         }
//       }
//     }

//     console.error('âŒ ALERT: All API keys have exceeded their quotas!');
//     logApiKeyStatus();
//     console.log('Falling back to local activity analysis');
//     return performLocalActivityAnalysis(activityData);
//   } catch (error) {
//     console.error('Unexpected error:', error.message);
//     console.log('Falling back to local activity analysis due to unexpected error');
//     return performLocalActivityAnalysis(activityData);
//   }
// };

// // Function to perform local password analysis without using the API
// const performLocalPasswordAnalysis = (password) => {
//   return createDefaultPasswordAnalysis(password);
// };

// // Export any other functions needed for the geminiService
// export const analyzePasswordWithAI = async (password, model = DEFAULT_MODEL, forceLocal = false) => {
//   try {
//     // Perform basic validation before sending to API
//     if (!password || password.length < 4) {
//       return createDefaultPasswordAnalysis(password);
//     }
    
//     // Skip API calls if we're in production, forcing local analysis, or if the override parameter is true
//     if (isProduction || forceLocalAnalysis || forceLocal) {
//       console.log('ðŸ”’ Using local password analysis (API bypassed)');
//       return performLocalPasswordAnalysis(password);
//     }
    
//     // Use the API key rotation system for password analysis as well
//     while (currentKeyIndex < API_KEYS.length) {
//       const GEMINI_API_KEY = API_KEYS[currentKeyIndex];
      
//       // Update last used timestamp
//       apiKeyStatus[currentKeyIndex].lastUsed = new Date();
      
//       // Define API URL inside the function
//       const GEMINI_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent`;
      
//       // Check if API key is available
//       if (!GEMINI_API_KEY) {
//         console.error('Password analysis: Missing API key');
//         currentKeyIndex++;
//         continue;
//       }
      
//       console.log(`Password analysis using API Key ${currentKeyIndex + 1}: ${GEMINI_API_KEY.substring(0, 5)}...`);
      
//       // Create a structured prompt for the AI to analyze
//       const prompt = `
//         You are a password security expert. Analyze this password (shown between triple quotes) to determine its strength:
        
//         """${password}"""
        
//         Provide:
//         1. A numeric score from 0-100 (with 100 being strongest)
//         2. A categorical strength assessment (Very Weak, Weak, Moderate, Strong, Very Strong)
//         3. Specific feedback on how to improve this password
//         4. A brief explanation of your assessment
        
//         Format your response as JSON:
//         {
//           "score": number between 0-100,
//           "strength": "categorical assessment",
//           "feedback": ["suggestion1", "suggestion2", ...],
//           "explanation": "brief explanation of assessment"
//         }
//       `;
      
//       try {
//         const response = await axios.post(
//           `${GEMINI_API_URL}?key=${GEMINI_API_KEY}`,
//           {
//             contents: [
//               {
//                 parts: [
//                   { text: prompt }
//                 ]
//               }
//             ],
//             generationConfig: {
//               temperature: 0.2,
//               maxOutputTokens: 800
//             }
//           },
//           {
//             headers: {
//               'Content-Type': 'application/json'
//             },
//             timeout: 5000 // 5 seconds timeout - shorter for better UX
//           }
//         );
        
//         // Extract and parse the JSON response from the AI
//         const rawText = response.data?.candidates?.[0]?.content?.parts?.[0]?.text;
        
//         if (!rawText) {
//           throw new Error('Empty response from AI API');
//         }
        
//         // Improved JSON extraction - handle potential text before/after JSON
//         let parsedResponse;
//         try {
//           // First try to parse the entire response as JSON
//           parsedResponse = JSON.parse(rawText);
//         } catch (parseError) {
//           // If that fails, try to extract JSON from the text
//           const jsonMatch = rawText.match(/\{[\s\S]*\}/);
//           if (!jsonMatch) {
//             throw new Error('No valid JSON found in AI response');
//           }
          
//           try {
//             parsedResponse = JSON.parse(jsonMatch[0]);
//           } catch (nestedParseError) {
//             throw new Error('Failed to parse JSON from AI response');
//           }
//         }
        
//         // Validate the parsed response has the required fields
//         if (!parsedResponse.score || !parsedResponse.strength || 
//             !Array.isArray(parsedResponse.feedback) || !parsedResponse.explanation) {
//           throw new Error('Incomplete analysis data from AI');
//         }
        
//         // Ensure score is a number between 0-100
//         parsedResponse.score = parseInt(parsedResponse.score);
//         if (isNaN(parsedResponse.score) || parsedResponse.score < 0 || parsedResponse.score > 100) {
//           parsedResponse.score = 50; // Default to middle if invalid
//         }
        
//         console.log('Successfully received and parsed password analysis');
//         return parsedResponse;
        
//       } catch (error) {
//         if (error.response && error.response.status === 429) {
//           console.warn(`âš ï¸ QUOTA EXCEEDED for API Key ${currentKeyIndex + 1} during password analysis`);
//           // Mark this key as exceeded
//           apiKeyStatus[currentKeyIndex].quotaExceeded = true;
//           currentKeyIndex++;
//           // Log the updated status of all keys
//           logApiKeyStatus();
//         } else {
//           console.error('Password analysis error:', error.message);
//           return performLocalPasswordAnalysis(password);
//         }
//       }
//     }
    
//     // If we've exhausted all keys
//     console.error('âŒ ALERT: All API keys have exceeded their quotas during password analysis!');
//     logApiKeyStatus();
//     return performLocalPasswordAnalysis(password);
//   } catch (error) {
//     console.error('Unexpected password analysis error:', error.message || 'Unknown error');
//     return performLocalPasswordAnalysis(password);
//   }
// };

// // Helper function to create a default password analysis
// const createDefaultPasswordAnalysis = (password) => {
//   // Basic strength calculation
//   let score = 0;
//   let strength = 'Very Weak';
//   let feedback = [];
  
//   // Length check
//   if (password.length >= 8) {
//     score += 20;
//     feedback.push('Password length is acceptable.');
//   } else {
//     feedback.push('Password should be at least 8 characters long.');
//   }
  
//   // Character diversity checks
//   if (/[A-Z]/.test(password)) score += 10;
//   else feedback.push('Add uppercase letters to strengthen your password.');
  
//   if (/[a-z]/.test(password)) score += 10;
//   else feedback.push('Add lowercase letters to strengthen your password.');
  
//   if (/[0-9]/.test(password)) score += 10;
//   else feedback.push('Add numbers to strengthen your password.');
  
//   if (/[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?]/.test(password)) score += 10;
//   else feedback.push('Add special characters to strengthen your password.');
  
//   // Determine strength based on score
//   if (score >= 50) strength = 'Strong';
//   else if (score >= 30) strength = 'Moderate';
//   else if (score >= 20) strength = 'Weak';
  
//   return {
//     score,
//     strength,
//     feedback,
//     explanation: 'This is a basic analysis generated locally. AI analysis was unavailable.',
//     isLocalAnalysis: true
//   };
// };

// // Export a function to get the current API key status
// export const getApiKeyStatus = () => {
//   return {
//     totalKeys: API_KEYS.length,
//     availableKeys: API_KEYS.length - apiKeyStatus.filter(key => key.quotaExceeded).length,
//     keyStatus: apiKeyStatus,
//     currentKeyIndex,
//     isProduction,
//     forceLocalAnalysis
//   };
// };

// // Reset a specific API key's quota exceeded status (useful if keys reset after time period)
// export const resetApiKeyQuota = (keyIndex) => {
//   if (keyIndex >= 0 && keyIndex < apiKeyStatus.length) {
//     apiKeyStatus[keyIndex].quotaExceeded = false;
//     console.log(`Reset quota status for API Key ${keyIndex + 1}`);
//     logApiKeyStatus();
//     return true;
//   }
//   return false;
// };

// // Reset all API keys' quota exceeded status
// export const resetAllApiKeyQuotas = () => {
//   apiKeyStatus.forEach(key => {
//     key.quotaExceeded = false;
//   });
//   currentKeyIndex = 0;
//   console.log('Reset quota status for all API keys');
//   logApiKeyStatus();
//   return true;
// };

// // Toggle force local analysis mode - allows you to switch modes at runtime
// export const setForceLocalAnalysis = (force) => {
//   const oldValue = forceLocalAnalysis;
//   // Update the forceLocalAnalysis value with the environment variable or the passed value
//   // Only update if the passed value is a boolean or the strings 'true'/'false'
//   if (typeof force === 'boolean' || force === 'true' || force === 'false') {
//     process.env.FORCE_LOCAL_ANALYSIS = String(force);
//     if (force === 'true' || force === true) {
//       console.log('ðŸ”’ Enabled force local analysis mode - All AI API calls will be bypassed');
//     } else {
//       console.log('ðŸ”“ Disabled force local analysis mode - AI API calls will be allowed (subject to environment)');
//     }
//     return { previous: oldValue, current: force === 'true' || force === true };
//   }
//   return { previous: oldValue, current: oldValue, unchanged: true };
// };







{/*local analysis*/}
// import dotenv from 'dotenv';
// import fs from 'fs';

// // Enhanced environment loading
// const loadEnvironment = () => {
//   // Try loading from different possible .env locations
//   const envPaths = ['.env', '../.env', '../../.env'];
  
//   for (const envPath of envPaths) {
//     if (fs.existsSync(envPath)) {
//       console.log(`Loading environment from ${envPath}`);
//       dotenv.config({ path: envPath });
//       break;
//     }
//   }
  
//   // Always call the default config as fallback
//   dotenv.config();
// };

// // Load environment variables
// loadEnvironment();

// // Helper function to create a response for activity analysis
// const createActivityAnalysis = (activity) => {
//   const { name, role, department, route, action, description } = activity;
  
//   // Define high-risk routes and actions
//   const highRiskRoutes = ['/admin', '/system', '/settings', '/users', '/permissions', '/security', '/logs', '/config'];
//   const highRiskActions = ['DELETE', 'MODIFY', 'UPDATE', 'CREATE', 'GRANT', 'REVOKE'];
  
//   // Define role-based risk levels
//   const roleLevels = {
//     'admin': 0,
//     'administrator': 0,
//     'sysadmin': 0,
//     'system administrator': 0,
//     'manager': 1,
//     'supervisor': 1,
//     'team lead': 1,
//     'developer': 2,
//     'engineer': 2,
//     'analyst': 2,
//     'staff': 3,
//     'user': 4,
//     'employee': 4,
//     'contractor': 5,
//     'intern': 5,
//     'guest': 6,
//     'visitor': 6,
//     'external': 7
//   };
  
//   // Calculate base risk score
//   let riskScore = 0;
//   const normalizedRole = role.toLowerCase();
//   const roleLevel = roleLevels[normalizedRole] !== undefined ? roleLevels[normalizedRole] : 4;
  
//   // Factor in role risk (higher number = higher risk)
//   riskScore += roleLevel * 5;
  
//   // Factor in route risk
//   const routeLower = route.toLowerCase();
//   for (const highRiskRoute of highRiskRoutes) {
//     if (routeLower.includes(highRiskRoute.toLowerCase())) {
//       riskScore += 15;
//       break;
//     }
//   }
  
//   // Factor in action risk
//   const actionUpper = action.toUpperCase();
//   for (const highRiskAction of highRiskActions) {
//     if (actionUpper.includes(highRiskAction)) {
//       riskScore += 20;
//       break;
//     }
//   }
  
//   // Check for suspicious keywords in description
//   const suspiciousKeywords = ['password', 'credential', 'token', 'secret', 'key', 'access', 'sudo', 'override', 'bypass'];
//   for (const keyword of suspiciousKeywords) {
//     if (description.toLowerCase().includes(keyword)) {
//       riskScore += 10;
//     }
//   }
  
//   // Determine risk level
//   let riskLevel = 'LOW';
//   if (riskScore >= 50) {
//     riskLevel = 'HIGH';
//   } else if (riskScore >= 25) {
//     riskLevel = 'MEDIUM';
//   }
  
//   // Determine category based on route and action
//   let category = 'General Activity';
//   if (route.toLowerCase().includes('user') || description.toLowerCase().includes('user')) {
//     category = 'User Management';
//   } else if (route.toLowerCase().includes('data') || description.toLowerCase().includes('data')) {
//     category = 'Data Access';
//   } else if (route.toLowerCase().includes('config') || route.toLowerCase().includes('setting')) {
//     category = 'System Configuration';
//   } else if (route.toLowerCase().includes('report') || route.toLowerCase().includes('dashboard')) {
//     category = 'Reporting';
//   } else if (route.toLowerCase().includes('log') || description.toLowerCase().includes('log')) {
//     category = 'Logging';
//   } else if (route.toLowerCase().includes('security') || description.toLowerCase().includes('security')) {
//     category = 'Security Operation';
//   }
  
//   // Detect unusual patterns
//   let patterns = 'No unusual patterns detected';
//   if (roleLevel > 3 && (route.includes('admin') || route.includes('system'))) {
//     patterns = 'Low-privilege user accessing high-privilege route';
//   } else if (description.toLowerCase().includes('fail') || description.toLowerCase().includes('error')) {
//     patterns = 'Failed operation detected';
//   } else if (description.toLowerCase().includes('multiple') || description.toLowerCase().includes('repeated')) {
//     patterns = 'Multiple or repeated actions detected';
//   } else if (actionUpper === 'DELETE' && roleLevel > 2) {
//     patterns = 'Low-privilege user performing deletion';
//   }
  
//   // Generate full analysis based on gathered data
//   let fullAnalysis = `User ${name} (${role} in ${department}) performed ${action} on ${route}. `;
  
//   if (riskLevel === 'HIGH') {
//     fullAnalysis += `This is a HIGH risk activity due to the sensitive nature of the ${category.toLowerCase()} and the user's role permissions. `;
//   } else if (riskLevel === 'MEDIUM') {
//     fullAnalysis += `This is a MEDIUM risk activity that warrants regular monitoring within the ${category.toLowerCase()}. `;
//   } else {
//     fullAnalysis += `This is a LOW risk activity that appears to be normal for the user's role and the ${category.toLowerCase()}. `;
//   }
  
//   if (patterns !== 'No unusual patterns detected') {
//     fullAnalysis += `Warning: ${patterns}. `;
//   }
  
//   fullAnalysis += `Action description: ${description}`;
  
//   return {
//     fullAnalysis,
//     category,
//     patterns,
//     riskLevel
//   };
// };

// // Main function to analyze user activity 
// export const analyzeActivityWithAI = async (activityData) => {
//   try {
//     const { name, role, department, route, action, description } = activityData;

//     // Validate that all required fields are present
//     if (!name || !role || !department || !route || !action || !description) {
//       console.error('Activity analysis error: Missing required fields');
//       return {
//         fullAnalysis: 'Activity analysis unavailable - missing required fields',
//         category: 'General activity',
//         patterns: 'No unusual patterns detected',
//         riskLevel: 'MEDIUM'
//       };
//     }

//     console.log('Performing local activity analysis...');
//     return createActivityAnalysis(activityData);
//   } catch (error) {
//     console.error('Unexpected error during activity analysis:', error.message);
//     return {
//       fullAnalysis: `Analysis error: ${error.message || 'Unknown error'}`,
//       category: 'General activity',
//       patterns: 'No unusual patterns detected',
//       riskLevel: 'MEDIUM'
//     };
//   }
// };

// // Password analysis function
// export const analyzePasswordWithAI = async (password) => {
//   try {
//     // Perform basic validation
//     if (!password || typeof password !== 'string') {
//       console.error('Password analysis error: Invalid password input');
//       return createDefaultPasswordAnalysis('');
//     }
    
//     console.log('Performing local password analysis...');
//     return createPasswordAnalysis(password);
//   } catch (error) {
//     console.error('Unexpected password analysis error:', error.message || 'Unknown error');
//     return createDefaultPasswordAnalysis(password);
//   }
// };

// // Enhanced password analysis function
// const createPasswordAnalysis = (password) => {
//   // Scoring variables
//   let score = 0;
//   let strength = 'Very Weak';
//   let feedback = [];
  
//   // Length check with graduated scoring
//   if (password.length >= 16) {
//     score += 25;
//     feedback.push('Excellent password length.');
//   } else if (password.length >= 12) {
//     score += 20;
//     feedback.push('Good password length.');
//   } else if (password.length >= 8) {
//     score += 15;
//     feedback.push('Acceptable password length.');
//   } else if (password.length >= 6) {
//     score += 5;
//     feedback.push('Password is too short. It should be at least 8 characters long.');
//   } else {
//     feedback.push('Password is critically short. It should be at least 8 characters long.');
//   }
  
//   // Character diversity checks
//   const hasUppercase = /[A-Z]/.test(password);
//   const hasLowercase = /[a-z]/.test(password);
//   const hasNumbers = /[0-9]/.test(password);
//   const hasSpecialChars = /[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?]/.test(password);
  
//   if (hasUppercase) score += 10;
//   else feedback.push('Add uppercase letters to strengthen your password.');
  
//   if (hasLowercase) score += 10;
//   else feedback.push('Add lowercase letters to strengthen your password.');
  
//   if (hasNumbers) score += 10;
//   else feedback.push('Add numbers to strengthen your password.');
  
//   if (hasSpecialChars) score += 15;
//   else feedback.push('Add special characters to strengthen your password.');
  
//   // Bonus for character diversity
//   const charTypes = [hasUppercase, hasLowercase, hasNumbers, hasSpecialChars].filter(Boolean).length;
//   if (charTypes >= 4) score += 15;
//   else if (charTypes >= 3) score += 10;
  
//   // Check for common patterns
//   const commonPatterns = [
//     '123', '1234', '12345', '123456', 'password', 'qwerty', 'admin', 'welcome',
//     'abc', 'abcd', 'abcde', 'qwert', 'asdf', 'zxcv'
//   ];
  
//   for (const pattern of commonPatterns) {
//     if (password.toLowerCase().includes(pattern)) {
//       score -= 15;
//       feedback.push(`Password contains a common pattern (${pattern}). Avoid predictable sequences.`);
//       break;
//     }
//   }
  
//   // Check for repeated characters
//   const repeatedChars = /(.)\1{2,}/.test(password);
//   if (repeatedChars) {
//     score -= 10;
//     feedback.push('Password contains repeated characters. Avoid using the same character multiple times in a row.');
//   }
  
//   // Ensure score is within bounds
//   score = Math.max(0, Math.min(100, score));
  
//   // Determine strength based on score
//   if (score >= 80) strength = 'Very Strong';
//   else if (score >= 60) strength = 'Strong';
//   else if (score >= 40) strength = 'Moderate';
//   else if (score >= 20) strength = 'Weak';
  
//   // Add general improvement tips if score is not perfect
//   if (score < 100) {
//     if (feedback.length === 0) {
//       feedback.push('Consider using a longer password with a mix of character types.');
//     }
    
//     // Add suggestion for a strong password if current one is weak
//     if (score < 60) {
//       feedback.push('Example of a strong password pattern: Mix uppercase, lowercase, numbers and special characters in an unpredictable way.');
//     }
//   } else if (feedback.length === 0) {
//     feedback.push('Excellent password! Keep it secure and don\'t reuse it across different services.');
//   }
  
//   let explanation = `This password scores ${score}/100. `;
  
//   if (score >= 80) {
//     explanation += 'This is a very strong password with good complexity and length.';
//   } else if (score >= 60) {
//     explanation += 'This is a strong password, but could be improved further.';
//   } else if (score >= 40) {
//     explanation += 'This password provides moderate security but has room for improvement.';
//   } else if (score >= 20) {
//     explanation += 'This password is weak and should be strengthened before use.';
//   } else {
//     explanation += 'This password is very weak and highly vulnerable to being compromised.';
//   }
  
//   return {
//     score,
//     strength,
//     feedback,
//     explanation
//   };
// };

// // Helper function to create a default password analysis
// const createDefaultPasswordAnalysis = (password) => {
//   // Basic strength calculation
//   let score = 0;
//   let strength = 'Very Weak';
//   let feedback = ['Unable to analyze password properly.', 'Use a mix of character types and avoid common patterns.'];
  
//   return {
//     score,
//     strength,
//     feedback,
//     explanation: 'This is a fallback analysis due to an error in the password analysis system.',
//     isDefaultAnalysis: true
//   };
// };

// // These functions are kept for compatibility but they don't do anything meaningful now
// export const getApiKeyStatus = () => {
//   return {
//     totalKeys: 0,
//     availableKeys: 0,
//     keyStatus: [],
//     currentKeyIndex: 0,
//     isLocalOnly: true
//   };
// };

// export const resetApiKeyQuota = () => {
//   console.log('This is a local-only implementation. No API keys to reset.');
//   return false;
// };

// export const resetAllApiKeyQuotas = () => {
//   console.log('This is a local-only implementation. No API keys to reset.');
//   return false;
// };







{/* eslint-disable no-console */      }
// //gemini open
// import axios from 'axios';
// import dotenv from 'dotenv';
// import fs from 'fs';
// import path from 'path';

// const DEFAULT_MODEL = 'gemini-1.5-pro-latest';

// // Enhanced environment loading
// const loadEnvironment = () => {
//   // Try loading from different possible .env locations
//   const envPaths = ['.env', '../.env', '../../.env'];
  
//   for (const envPath of envPaths) {
//     if (fs.existsSync(envPath)) {
//       console.log(`Loading environment from ${envPath}`);
//       dotenv.config({ path: envPath });
//       break;
//     }
//   }
  
//   // Always call the default config as fallback
//   dotenv.config();
// };

// // Load environment variables
// loadEnvironment();

// // Helper function to create a default response
// const createDefaultResponse = (message) => {
//   return {
//     fullAnalysis: message,
//     category: 'General activity',
//     patterns: 'No unusual patterns detected',
//     riskLevel: 'MEDIUM'  // Changed from UNKNOWN to MEDIUM
//   };
// };

// const API_KEYS = [
//   process.env.GEMINI_API_KEY1,
//   process.env.GEMINI_API_KEY2,
//   process.env.GEMINI_API_KEY3,
//   process.env.GEMINI_API_KEY4, 
//   process.env.GEMINI_API_KEY5, 
//   process.env.GEMINI_API_KEY6, 
// ];

// // Create a key status tracking object
// const apiKeyStatus = API_KEYS.map((key, index) => ({
//   key: key ? key.substring(0, 5) + '...' : 'undefined',
//   index,
//   quotaExceeded: false,
//   lastUsed: null
// }));

// // Add this function to visualize API key status
// const logApiKeyStatus = () => {
//   console.log('\n=== API Key Status ===');
//   apiKeyStatus.forEach(key => {
//     const status = key.quotaExceeded ? 
//       'QUOTA EXCEEDED' : 
//       'AVAILABLE';
//     const lastUsed = key.lastUsed ? 
//       `Last used: ${key.lastUsed.toLocaleTimeString()}` : 
//       'Not used yet';
//     console.log(`Key ${key.index + 1} (${key.key}): ${status} - ${lastUsed}`);
//   });
//   console.log('=====================\n');
// };

// let currentKeyIndex = 0;

// export const analyzeActivityWithAI = async (activityData, model = DEFAULT_MODEL) => {
//   try {
//     const { name, role, department, route, action, description } = activityData;

//     // Validate that all required fields are present
//     if (!name || !role || !department || !route || !action || !description) {
//       console.error('AI analysis error: Missing required fields');
//       return createDefaultResponse('AI analysis unavailable - missing required fields');
//     }

//     // Create a structured prompt for the AI to analyze
//     const prompt = `
//     You are a security and user behavior analysis expert. Analyze this user activity:
  
//     User: ${name}
//     Role: ${role}
//     Department: ${department}
//     Route: ${route}
//     Action: ${action}
//     Description: ${description}
  
//     Provide detailed analysis about:
//     1. Categorization of this activity (e.g., Data Access, User Management, System Configuration)
//     2. Any unusual patterns or behaviors
//     3. Risk assessment: LOW, MEDIUM, or HIGH based on:
//        - User role and permissions (e.g., "Guest" performing "DELETE" is HIGH risk)
//        - Sensitivity of the route or action (e.g., accessing "/admin/settings" is HIGH risk)
//        - Unusual patterns or behaviors (e.g., repeated failed login attempts)
  
//     Examples:
//     - A "Guest" user attempting to "DELETE" sensitive data is HIGH risk.
//     - An "Admin" user viewing a dashboard is LOW risk.
//     - A "Manager" updating user permissions is MEDIUM risk.
  
//     Format your response as JSON:
//     {
//       "fullAnalysis": "detailed explanation of your overall analysis",
//       "category": "brief category name",
//       "patterns": "description of any unusual patterns or 'No unusual patterns detected'",
//       "riskLevel": "LOW", "MEDIUM", or "HIGH"
//     }
//   `;
//     while (currentKeyIndex < API_KEYS.length) {
//       const GEMINI_API_KEY = API_KEYS[currentKeyIndex];
//       const GEMINI_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent`;

//       // Update last used timestamp
//       apiKeyStatus[currentKeyIndex].lastUsed = new Date();
      
//       console.log(`Using API Key ${currentKeyIndex + 1}: ${GEMINI_API_KEY.substring(0, 5)}...`);

//       try {
//         const response = await axios.post(
//           `${GEMINI_API_URL}?key=${GEMINI_API_KEY}`,
//           {
//             contents: [
//               {
//                 parts: [
//                   { text: prompt }
//                 ]
//               }
//             ],
//             generationConfig: {
//               temperature: 0.2,
//               maxOutputTokens: 800
//             }
//           },
//           {
//             headers: {
//               'Content-Type': 'application/json'
//             },
//             timeout: 15000 // 15 seconds timeout
//           }
//         );

//         // Extract and parse the JSON response from the AI
//         const rawText = response.data?.candidates?.[0]?.content?.parts?.[0]?.text;

//         if (!rawText) {
//           throw new Error('Empty or invalid response from AI API');
//         }

//         let parsedResponse;
//         try {
//           parsedResponse = JSON.parse(rawText);
//         } catch (parseError) {
//           const jsonMatch = rawText.match(/\{[\s\S]*\}/);
//           if (!jsonMatch) {
//             throw new Error('No valid JSON found in AI response');
//           }
//           parsedResponse = JSON.parse(jsonMatch[0]);
//         }

//         if (!parsedResponse.fullAnalysis || !parsedResponse.category || 
//             !parsedResponse.patterns || !parsedResponse.riskLevel) {
//           throw new Error('Incomplete analysis data from AI');
//         }

//         parsedResponse.riskLevel = parsedResponse.riskLevel.toUpperCase();
//         if (!['LOW', 'MEDIUM', 'HIGH'].includes(parsedResponse.riskLevel)) {
//           parsedResponse.riskLevel = 'MEDIUM';
//         }

//         console.log('Successfully received and parsed AI response');
//         return parsedResponse;

//       } catch (error) {
//         if (error.response && error.response.status === 429) {
//           console.warn(`âš ï¸ QUOTA EXCEEDED for API Key ${currentKeyIndex + 1}`);
//           // Mark this key as exceeded
//           apiKeyStatus[currentKeyIndex].quotaExceeded = true;
//           currentKeyIndex++;
//           // Log the updated status of all keys
//           logApiKeyStatus();
//         } else {
//           console.error('AI analysis error:', error.message);
//           return createDefaultResponse(`AI analysis error: ${error.message || 'Unknown error'}`);
//         }
//       }
//     }

//     console.error('âŒ ALERT: All API keys have exceeded their quotas!');
//     logApiKeyStatus();
//     return createDefaultResponse('AI analysis unavailable - all API keys exceeded their quotas');
//   } catch (error) {
//     console.error('Unexpected error:', error.message);
//     return createDefaultResponse(`AI analysis error: ${error.message || 'Unknown error'}`);
//   }
// };

// // Export any other functions needed for the geminiService
// export const analyzePasswordWithAI = async (password, model = DEFAULT_MODEL) => {
//   try {
//     // Perform basic validation before sending to API
//     if (!password || password.length < 4) {
//       return createDefaultPasswordAnalysis(password);
//     }
    
//     // Use the API key rotation system for password analysis as well
//     while (currentKeyIndex < API_KEYS.length) {
//       const GEMINI_API_KEY = API_KEYS[currentKeyIndex];
      
//       // Update last used timestamp
//       apiKeyStatus[currentKeyIndex].lastUsed = new Date();
      
//       // Define API URL inside the function
//       const GEMINI_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent`;
      
//       // Check if API key is available
//       if (!GEMINI_API_KEY) {
//         console.error('Password analysis: Missing API key');
//         currentKeyIndex++;
//         continue;
//       }
      
//       console.log(`Password analysis using API Key ${currentKeyIndex + 1}: ${GEMINI_API_KEY.substring(0, 5)}...`);
      
//       // Create a structured prompt for the AI to analyze
//       const prompt = `
//         You are a password security expert. Analyze this password (shown between triple quotes) to determine its strength:
        
//         """${password}"""
        
//         Provide:
//         1. A numeric score from 0-100 (with 100 being strongest)
//         2. A categorical strength assessment (Very Weak, Weak, Moderate, Strong, Very Strong)
//         3. Specific feedback on how to improve this password
//         4. A brief explanation of your assessment
        
//         Format your response as JSON:
//         {
//           "score": number between 0-100,
//           "strength": "categorical assessment",
//           "feedback": ["suggestion1", "suggestion2", ...],
//           "explanation": "brief explanation of assessment"
//         }
//       `;
      
//       try {
//         const response = await axios.post(
//           `${GEMINI_API_URL}?key=${GEMINI_API_KEY}`,
//           {
//             contents: [
//               {
//                 parts: [
//                   { text: prompt }
//                 ]
//               }
//             ],
//             generationConfig: {
//               temperature: 0.2,
//               maxOutputTokens: 800
//             }
//           },
//           {
//             headers: {
//               'Content-Type': 'application/json'
//             },
//             timeout: 5000 // 5 seconds timeout - shorter for better UX
//           }
//         );
        
//         // Extract and parse the JSON response from the AI
//         const rawText = response.data?.candidates?.[0]?.content?.parts?.[0]?.text;
        
//         if (!rawText) {
//           throw new Error('Empty response from AI API');
//         }
        
//         // Improved JSON extraction - handle potential text before/after JSON
//         let parsedResponse;
//         try {
//           // First try to parse the entire response as JSON
//           parsedResponse = JSON.parse(rawText);
//         } catch (parseError) {
//           // If that fails, try to extract JSON from the text
//           const jsonMatch = rawText.match(/\{[\s\S]*\}/);
//           if (!jsonMatch) {
//             throw new Error('No valid JSON found in AI response');
//           }
          
//           try {
//             parsedResponse = JSON.parse(jsonMatch[0]);
//           } catch (nestedParseError) {
//             throw new Error('Failed to parse JSON from AI response');
//           }
//         }
        
//         // Validate the parsed response has the required fields
//         if (!parsedResponse.score || !parsedResponse.strength || 
//             !Array.isArray(parsedResponse.feedback) || !parsedResponse.explanation) {
//           throw new Error('Incomplete analysis data from AI');
//         }
        
//         // Ensure score is a number between 0-100
//         parsedResponse.score = parseInt(parsedResponse.score);
//         if (isNaN(parsedResponse.score) || parsedResponse.score < 0 || parsedResponse.score > 100) {
//           parsedResponse.score = 50; // Default to middle if invalid
//         }
        
//         console.log('Successfully received and parsed password analysis');
//         return parsedResponse;
        
//       } catch (error) {
//         if (error.response && error.response.status === 429) {
//           console.warn(`âš ï¸ QUOTA EXCEEDED for API Key ${currentKeyIndex + 1} during password analysis`);
//           // Mark this key as exceeded
//           apiKeyStatus[currentKeyIndex].quotaExceeded = true;
//           currentKeyIndex++;
//           // Log the updated status of all keys
//           logApiKeyStatus();
//         } else {
//           console.error('Password analysis error:', error.message);
//           return createDefaultPasswordAnalysis(password);
//         }
//       }
//     }
    
//     // If we've exhausted all keys
//     console.error('âŒ ALERT: All API keys have exceeded their quotas during password analysis!');
//     logApiKeyStatus();
//     return createDefaultPasswordAnalysis(password);
//   } catch (error) {
//     console.error('Unexpected password analysis error:', error.message || 'Unknown error');
//     return createDefaultPasswordAnalysis(password);
//   }
// };

// // Helper function to create a default password analysis
// const createDefaultPasswordAnalysis = (password) => {
//   // Basic strength calculation
//   let score = 0;
//   let strength = 'Very Weak';
//   let feedback = [];
  
//   // Length check
//   if (password.length >= 8) {
//     score += 20;
//     feedback.push('Password length is acceptable.');
//   } else {
//     feedback.push('Password should be at least 8 characters long.');
//   }
  
//   // Character diversity checks
//   if (/[A-Z]/.test(password)) score += 10;
//   else feedback.push('Add uppercase letters to strengthen your password.');
  
//   if (/[a-z]/.test(password)) score += 10;
//   else feedback.push('Add lowercase letters to strengthen your password.');
  
//   if (/[0-9]/.test(password)) score += 10;
//   else feedback.push('Add numbers to strengthen your password.');
  
//   if (/[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?]/.test(password)) score += 10;
//   else feedback.push('Add special characters to strengthen your password.');
  
//   // Determine strength based on score
//   if (score >= 50) strength = 'Strong';
//   else if (score >= 30) strength = 'Moderate';
//   else if (score >= 20) strength = 'Weak';
  
//   return {
//     score,
//     strength,
//     feedback,
//     explanation: 'This is a basic analysis generated locally. AI analysis was unavailable.',
//     isDefaultAnalysis: true
//   };
// };

// // Export a function to get the current API key status
// export const getApiKeyStatus = () => {
//   return {
//     totalKeys: API_KEYS.length,
//     availableKeys: API_KEYS.length - apiKeyStatus.filter(key => key.quotaExceeded).length,
//     keyStatus: apiKeyStatus,
//     currentKeyIndex
//   };
// };

// // Reset a specific API key's quota exceeded status (useful if keys reset after time period)
// export const resetApiKeyQuota = (keyIndex) => {
//   if (keyIndex >= 0 && keyIndex < apiKeyStatus.length) {
//     apiKeyStatus[keyIndex].quotaExceeded = false;
//     console.log(`Reset quota status for API Key ${keyIndex + 1}`);
//     logApiKeyStatus();
//     return true;
//   }
//   return false;
// };

// // Reset all API keys' quota exceeded status
// export const resetAllApiKeyQuotas = () => {
//   apiKeyStatus.forEach(key => {
//     key.quotaExceeded = false;
//   });
//   currentKeyIndex = 0;
//   console.log('Reset quota status for all API keys');
//   logApiKeyStatus();
//   return true;
// };