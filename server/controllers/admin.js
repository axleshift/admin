import path from 'path';
import fs from 'fs';
import { exec } from 'child_process';
import archiver from 'archiver';
import extract from "extract-zip";
import dotenv from 'dotenv';

import { GoogleGenerativeAI } from "@google/generative-ai";
import Message from '../model/message.js'
import User from '../model/User.js'
import passport from 'passport'
import { Strategy as GitHubStrategy } from "passport-github2";
import jwt  from 'jsonwebtoken'


dotenv.config();


const gemini = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);


const isWindows = process.platform === 'win32';

// Improved path normalization that preserves Windows drive letters
const normalizePath = (filepath) => {
  if (!filepath) return '';
  const normalized = path.normalize(filepath);
  // Replace backslashes with forward slashes but preserve drive letter format on Windows
  return normalized.replace(/\\/g, '/');
};

// Convert relative paths to absolute paths
const ensureAbsolutePath = (dirPath) => {
  if (!dirPath) return '';
  if (path.isAbsolute(dirPath)) {
    return dirPath;
  }
  return path.resolve(process.cwd(), dirPath);
};
let backupDir = process.env.BACKUP_DIRECTORY || path.join(process.cwd(), 'backups');
backupDir = ensureAbsolutePath(backupDir);
const mongoURL = process.env.MONGO_URL;
const databaseName = process.env.DATABASE_NAME || 'adminis';

// Initialize backup directory
try {
  if (!fs.existsSync(backupDir)) {
    fs.mkdirSync(backupDir, { recursive: true });
    console.log(`Created default backup directory: ${backupDir}`);
  }
} catch (error) {
  console.error(`Failed to create default backup directory: ${error.message}`);
}


async function generateImage(prompt, username) {
  try {
    // Use gemini-1.5-pro model which supports image generation
    const model = gemini.getGenerativeModel({ model: "gemini-1.5-pro" });
    
    // Create the generation request
    const result = await model.generateContent({
      contents: [
        {
          role: "user",
          parts: [
            { text: `Generate a detailed image of: ${prompt}` }
          ]
        }
      ],
      generationConfig: {
        temperature: 0.7,
        maxOutputTokens: 4096,
      }
    });
    
    // Process the response
    const response = result.response;
    const imageData = response.candidates[0].content.parts.find(part => part.inlineData);
    
    if (!imageData) {
      throw new Error("No image was generated by the model");
    }
    
    // Get the base64 image data
    const imageBase64 = imageData.inlineData.data;
    const mimeType = imageData.inlineData.mimeType || 'image/png';
    
    // Store image generation in database
    const timestamp = Date.now();
    const filename = `${username || 'anonymous'}_${timestamp}.png`;
    
    const imageRecord = new Message({
      content: prompt,
      type: 'image',
      metadata: {
        requester: username || 'anonymous',
        prompt,
        filename,
        timestamp
      },
      status: 'completed'
    });
    
    await imageRecord.save();
    
    return {
      success: true,
      imageId: imageRecord._id,
      imageData: imageBase64,
      mimeType,
      prompt
    };
  } catch (error) {
    console.error('Image generation error:', error);
    throw error;
  }
}


// Fix for setBackupDirectory function
export const setBackupDirectory = (req, res) => {
  const { directory } = req.body;

  if (!directory) {
    return res.status(400).json({ message: 'Directory is required' });
  }

  try {
    let absolutePath;
    
    // Handle Windows-style paths correctly
    if (isWindows && /^[a-zA-Z]:[\\\/]/.test(directory)) {
      absolutePath = directory;
      console.log("Windows absolute path detected:", absolutePath);
    } else {
      absolutePath = path.resolve(directory);
      console.log("Resolved path:", absolutePath);
    }
    
    // Store the normalized path
    backupDir = normalizePath(absolutePath);
    
    console.log(`Setting backup directory to: ${backupDir}`);
    
    // Create directory if it doesn't exist
    if (!fs.existsSync(backupDir)) {
      try {
        fs.mkdirSync(backupDir, { recursive: true });
        console.log(`Created directory: ${backupDir}`);
      } catch (error) {
        console.error(`Failed to create directory: ${error.message}`);
        return res.status(500).json({ 
          message: `Failed to create directory: ${error.message}`,
          error: error.toString()
        });
      }
    }
    
    // Verify write permissions by creating a test file
    const testFilePath = path.join(backupDir, '.test_write_access');
    try {
      fs.writeFileSync(testFilePath, 'test', { encoding: 'utf8' });
      fs.unlinkSync(testFilePath); // Remove test file
      console.log(`Successfully verified write access to: ${backupDir}`);
    } catch (writeError) {
      console.error(`Failed to write to directory: ${writeError.message}`);
      return res.status(500).json({
        message: `No write permission to directory: ${writeError.message}`,
        error: writeError.toString()
      });
    }
    
    // Persist the backup directory in environment if possible
    try {
      if (fs.existsSync('.env')) {
        const envContent = fs.readFileSync('.env', 'utf8');
        const envLines = envContent.split('\n');
        let found = false;
        
        const updatedLines = envLines.map(line => {
          if (line.startsWith('BACKUP_DIRECTORY=')) {
            found = true;
            return `BACKUP_DIRECTORY=${backupDir}`;
          }
          return line;
        });
        
        if (!found) {
          updatedLines.push(`BACKUP_DIRECTORY=${backupDir}`);
        }
        
        fs.writeFileSync('.env', updatedLines.join('\n'));
        console.log(`Updated BACKUP_DIRECTORY in .env file`);
      }
    } catch (envError) {
      console.warn(`Could not update .env file: ${envError.message}`);
      // Non-fatal error, continue
    }
    
    // Update process environment
    process.env.BACKUP_DIRECTORY = backupDir;
    
    res.status(200).json({ 
      message: `Backup directory set to: ${backupDir}`,
      directory: backupDir // Return the directory to confirm it was set
    });
  } catch (error) {
    console.error(`Directory setup error: ${error.message}`);
    return res.status(500).json({ 
      message: `Failed to set backup directory: ${error.message}`,
      error: error.toString() 
    });
  }
};

export const getBackupDirectory = (req, res) => {
  res.status(200).json({ 
    directory: backupDir,
    exists: fs.existsSync(backupDir)
  });
};

export const backupDatabase = async (req, res) => {
  console.log(`Starting database backup using directory: ${backupDir}`);

  // Double-check that backup directory exists and we can access it
  if (!fs.existsSync(backupDir)) {
    try {
      fs.mkdirSync(backupDir, { recursive: true });
      console.log(`Created backup directory: ${backupDir}`);
    } catch (createError) {
      console.error(`Failed to create backup directory: ${createError.message}`);
      return res.status(500).json({ 
        message: `Failed to create backup directory: ${createError.message}` 
      });
    }
  }

  // Create timestamp for the backup
  const now = new Date();
  const timestamp = now.toISOString().replace(/:/g, '-').replace(/\..+/, '').replace('T', '_');
  
  // Create absolute paths with normalized separators
  const backupDirPath = normalizePath(path.join(backupDir, timestamp));
  const archivePath = normalizePath(`${backupDirPath}.zip`);

  console.log(`Creating backup at: ${backupDirPath}`);
  console.log(`Archive will be created at: ${archivePath}`);

  try {
    // Ensure backup subdirectory exists
    if (!fs.existsSync(backupDirPath)) {
      fs.mkdirSync(backupDirPath, { recursive: true });
      console.log(`Created backup subdirectory: ${backupDirPath}`);
    }

    if (!mongoURL) {
      console.error('MongoDB URL is not defined');
      return res.status(500).json({ message: 'MongoDB connection URL is not configured' });
    }

    console.log(`Starting mongodump with database: ${databaseName}`);
    
    // Run `mongodump` with properly escaped paths
    try {
      // Always use quoted paths to handle spaces correctly
      const mongoCommand = process.env.MONGODUMP_PATH || 'mongodump';
      
      // Create command with proper quoting for different platforms
      let command;
      if (isWindows) {
        command = `${mongoCommand} --uri "${mongoURL}" --db ${databaseName} --out "${backupDirPath}"`;
      } else {
        command = `${mongoCommand} --uri '${mongoURL}' --db ${databaseName} --out '${backupDirPath}'`;
      }
      
      console.log(`Executing command: ${command}`);
      
      const { stdout, stderr } = await new Promise((resolve, reject) => {
        exec(command, (error, stdout, stderr) => {
          if (error) {
            console.error('Error executing mongodump:', error);
            console.error('stderr:', stderr);
            return reject(error);
          }
          resolve({ stdout, stderr });
        });
      });
      
      console.log('mongodump stdout:', stdout);
      if (stderr) console.log('mongodump stderr:', stderr);
      
      // Verify mongodump output exists
      const dbOutputPath = path.join(backupDirPath, databaseName);
      if (!fs.existsSync(dbOutputPath)) {
        throw new Error(`mongodump did not create expected output at ${dbOutputPath}`);
      }
      
      console.log('mongodump completed successfully');
    } catch (dumpError) {
      console.error('mongodump failed:', dumpError);
      return res.status(500).json({ 
        message: 'Database backup failed during mongodump', 
        error: dumpError.message 
      });
    }

    // Create zip archive
    const output = fs.createWriteStream(archivePath);
    const archive = archiver('zip', { zlib: { level: 9 } });

    archive.on('error', (err) => {
      console.error('Archiver Error:', err);
      return res.status(500).json({ message: 'Error compressing backup', error: err.message });
    });

    const archivePromise = new Promise((resolve, reject) => {
      output.on('close', () => {
        console.log(`Backup archived: ${archivePath} (${archive.pointer()} bytes)`);
        resolve();
      });
      
      output.on('error', (err) => {
        console.error('Output stream error:', err);
        reject(err);
      });
    });

    archive.pipe(output);
    archive.directory(backupDirPath, false);
    await archive.finalize();
    
    await archivePromise;
    
    // Cleanup: Remove original backup folder asynchronously
    fs.rm(backupDirPath, { recursive: true, force: true }, (err) => {
      if (err) {
        console.error('Failed to remove backup folder:', err);
      } else {
        console.log(`Cleaned up temporary directory: ${backupDirPath}`);
      }
    });

    res.status(200).json({
      message: 'Backup created and archived successfully',
      archivePath: archivePath,
    });
  } catch (error) {
    console.error('Backup failed:', error);
    return res.status(500).json({ message: 'Backup failed', error: error.message });
  }
};

export const listBackups = (req, res) => {
  console.log(`Listing backups from directory: ${backupDir}`);

  try {
    if (!fs.existsSync(backupDir)) {
      console.error(`Directory does not exist: ${backupDir}`);
      return res.status(400).json({ message: "Backup directory does not exist", backups: [] });
    }

    const files = fs.readdirSync(backupDir);
    console.log(`Found ${files.length} files in backup directory`);
    
    const backups = files
      .filter(file => file.endsWith(".zip")) // Only show ZIP archives
      .map(file => {
        const filePath = path.join(backupDir, file);
        const stats = fs.statSync(filePath);
        console.log(`Processing backup file: ${file}, created: ${stats.birthtime}`);
        return {
          name: file,
          path: normalizePath(filePath),
          created: stats.birthtime,
          size: stats.size
        };
      })
      .sort((a, b) => b.created - a.created); // Sort newest first

    console.log(`Returning ${backups.length} backup entries`);
    res.status(200).json({ backups });
  } catch (error) {
    console.error("Error listing backups:", error);
    res.status(500).json({ message: "Failed to list backups", error: error.message, backups: [] });
  }
};

export const listCollections = async (req, res) => {
  const { backupName } = req.params;
  const { databaseName } = req.query; // Use query parameters for database name

  console.log(`Listing collections from backup: ${backupName}, database: ${databaseName || 'not specified'}`);
  console.log(`Using backup directory: ${backupDir}`);

  // Make sure we have absolute paths for both archive and temp dir
  const archivePath = path.resolve(path.join(backupDir, backupName));
  const tempDirName = `temp_${Date.now()}`;
  const tempDir = path.resolve(path.join(backupDir, tempDirName));

  console.log(`Archive absolute path: ${archivePath}`);
  console.log(`Temp directory absolute path: ${tempDir}`);

  try {
    // Ensure the backup file exists before extracting
    if (!fs.existsSync(archivePath)) {
      console.error(`Backup file not found: ${archivePath}`);
      return res.status(400).json({ message: `Backup file ${backupName} not found.` });
    }

    // Ensure temp directory exists
    if (!fs.existsSync(tempDir)) {
      fs.mkdirSync(tempDir, { recursive: true });
      console.log(`Created temp directory: ${tempDir}`);
    }

    // Extract the backup archive - crucial fix: ensure both paths are absolute
    console.log(`Extracting backup: ${archivePath} to ${tempDir}`);
    try {
      await extract(archivePath, { dir: tempDir });
      console.log('Extraction completed successfully');
    } catch (extractError) {
      console.error('Extract error details:', extractError);
      throw new Error(`Extraction failed: ${extractError.message}`);
    }

    if (!databaseName) {
      // If no database is specified, return a list of databases
      const contents = fs.readdirSync(tempDir);
      console.log(`Contents of extracted backup: ${contents}`);
      
      const databases = contents.filter(item => 
        fs.statSync(path.join(tempDir, item)).isDirectory()
      );

      console.log(`Databases found: ${databases}`);
      return res.status(200).json({ databases });
    }

    // Check if the selected database exists
    const dbPath = path.join(tempDir, databaseName);
    if (!fs.existsSync(dbPath)) {
      console.error(`Database path not found: ${dbPath}`);
      return res.status(400).json({ message: `Database ${databaseName} not found in backup.` });
    }

    // Return BSON collections inside the selected database
    const dbContents = fs.readdirSync(dbPath);
    console.log(`Contents of database directory: ${dbContents}`);
    
    const collections = dbContents.filter(file => file.endsWith(".bson"));

    console.log(`Collections found in ${databaseName}: ${collections}`);
    return res.status(200).json({ collections });
  } catch (error) {
    console.error("Error listing collections:", error);
    res.status(500).json({ message: "Failed to list collections", error: error.message });
  } finally {
    // Cleanup extracted files safely
    console.log(`Scheduling cleanup of temp directory: ${tempDir}`);
    setTimeout(() => {
      fs.rm(tempDir, { recursive: true, force: true }, (err) => {
        if (err) {
          console.error("Failed to remove temp extraction folder:", err);
        } else {
          console.log(`Successfully removed temp directory: ${tempDir}`);
        }
      });
    }, 5000);
  }
};

export const restoreDatabase = async (req, res) => {
  const { timestamp, filename, databaseName } = req.body;

  if (!timestamp || !filename || !databaseName) {
    return res.status(400).json({ 
      message: 'All inputs are required: timestamp, filename, and database name.' 
    });
  }

  console.log(`Restore request for backup: ${timestamp}, database: ${databaseName}, collection: ${filename}`);
  console.log(`Using backup directory: ${backupDir}`);

  let tempDir = null;
  
  try {
    // Construct the complete path to the backup file using absolute paths
    const backupPath = path.resolve(path.join(backupDir, timestamp));
    console.log(`Backup absolute path: ${backupPath}`);
    
    // Verify the backup file exists before proceeding
    if (!fs.existsSync(backupPath)) {
      console.error(`Backup file not found: ${backupPath}`);
      return res.status(400).json({ 
        message: `Backup file not found: ${backupPath}` 
      });
    }
    
    // Create a temporary directory with a unique name for extraction
    const tempDirName = `temp_restore_${Date.now()}`;
    tempDir = path.resolve(path.join(backupDir, tempDirName));
    fs.mkdirSync(tempDir, { recursive: true });
    console.log(`Created temp directory: ${tempDir}`);
    
    // Extract the archive with absolute paths
    console.log(`Extracting ${backupPath} to ${tempDir}`);
    try {
      await extract(backupPath, { dir: tempDir });
      console.log('Extraction completed successfully');
    } catch (extractError) {
      console.error('Extract error details:', extractError);
      throw new Error(`Extraction failed: ${extractError.message}`);
    }
    
    // Construct the path to the BSON file
    const dbDir = path.join(tempDir, databaseName);
    const filePath = path.join(dbDir, filename);
    
    console.log(`Looking for file at: ${filePath}`);
    
    // Check if the extracted files and directories exist
    if (!fs.existsSync(dbDir)) {
      console.error(`Database directory not found: ${dbDir}`);
      throw new Error(`Database directory not found: ${dbDir}`);
    }
    
    if (!fs.existsSync(filePath)) {
      console.error(`Collection file not found: ${filePath}`);
      throw new Error(`Collection file not found: ${filePath}`);
    }

    // Get collection name from filename (remove .bson extension)
    const collectionName = path.basename(filename, '.bson');
    console.log(`Collection name: ${collectionName}`);
    
    // Ensure mongoURL is properly defined in your environment
    if (!mongoURL) {
      console.error('MongoDB connection URL is not defined');
      throw new Error('MongoDB connection URL is not defined');
    }
    
    // Create the mongorestore command with proper quoting based on platform
    const mongoCommand = process.env.MONGORESTORE_PATH || 'mongorestore';
    
    let command;
    if (isWindows) {
      command = `${mongoCommand} --uri="${mongoURL}" --nsInclude="${databaseName}.${collectionName}" --drop "${filePath}"`;
    } else {
      command = `${mongoCommand} --uri='${mongoURL}' --nsInclude="${databaseName}.${collectionName}" --drop '${filePath}'`;
    }
    
    console.log(`Executing restore command: ${command}`);

    // Execute the command and capture output
    const { stdout, stderr } = await new Promise((resolve, reject) => {
      exec(command, (error, stdout, stderr) => {
        if (error) {
          console.error(`mongorestore error: ${error.message}`);
          console.error(`stderr: ${stderr}`);
          return reject(error);
        }
        resolve({ stdout, stderr });
      });
    });
    
    console.log(`Restore stdout: ${stdout}`);
    if (stderr) console.log(`Restore stderr: ${stderr}`);
    
    res.status(200).json({ 
      message: `Collection '${collectionName}' restored successfully` 
    });
  } catch (error) {
    console.error('Restore failed:', error);
    
    res.status(500).json({ 
      message: `Restore failed: ${error.message}`,
      error: error.toString()
    });
  } finally {
    // Clean up the temporary directory regardless of success or failure
    if (tempDir && fs.existsSync(tempDir)) {
      console.log(`Cleaning up temp directory: ${tempDir}`);
      try {
        fs.rmSync(tempDir, { recursive: true, force: true });
        console.log(`Successfully removed temp directory: ${tempDir}`);
      } catch (cleanupError) {
        console.error('Failed to clean up temp directory:', cleanupError);
      }
    }
  }
};
//announcement .js




//chat.js

export const chatbox = async (req, res) => {
  const { message, conversationHistory } = req.body;

  if (!message || !message.trim()) {
    return res.status(400).json({ error: 'Message cannot be empty' });
  }

  try {
    // Simple response logic based on input
    let botReply;
    const userMessage = message.toLowerCase().trim();
    const username = req.session?.username;

    // Check if the message is an image generation request
    if (
      userMessage.startsWith('generate image') || 
      userMessage.startsWith('create image') || 
      userMessage.startsWith('make image') || 
      userMessage.startsWith('draw') || 
      userMessage.includes('make a picture of') || 
      userMessage.includes('show me an image of')
    ) {
      // Extract the image prompt from the message
      let imagePrompt = '';
      
      if (userMessage.startsWith('generate image')) {
        imagePrompt = message.substring('generate image'.length).trim();
      } else if (userMessage.startsWith('create image')) {
        imagePrompt = message.substring('create image'.length).trim();
      } else if (userMessage.startsWith('make image')) {
        imagePrompt = message.substring('make image'.length).trim();
      } else if (userMessage.startsWith('draw')) {
        imagePrompt = message.substring('draw'.length).trim();
      } else if (userMessage.includes('make a picture of')) {
        imagePrompt = message.substring(message.indexOf('make a picture of') + 'make a picture of'.length).trim();
      } else if (userMessage.includes('show me an image of')) {
        imagePrompt = message.substring(message.indexOf('show me an image of') + 'show me an image of'.length).trim();
      }
      
      // Remove any leading colons or "of" word
      imagePrompt = imagePrompt.replace(/^[:\s]+|of\s+/, '').trim();
      
      if (!imagePrompt) {
        botReply = "Please provide a description for the image you want me to generate.";
        
        // Standard text response
        const updatedHistory = [
          ...(conversationHistory || []),
          { text: message, sender: 'user' },
          { text: botReply, sender: 'gemini' },
        ];
        
        return res.json({
          response: botReply,
          conversationHistory: updatedHistory,
        });
      }
      
      try {
        // Generate the image
        const imageResult = await generateImage(imagePrompt, username);
        
        botReply = `I've created an image based on: "${imagePrompt}"`;
        
        // Return with the image data
        const updatedHistory = [
          ...(conversationHistory || []),
          { text: message, sender: 'user' },
          { 
            text: botReply, 
            sender: 'gemini',
            type: 'image',
            imageData: imageResult.imageData,
            imageId: imageResult.imageId,
            prompt: imagePrompt
          },
        ];
        
        return res.json({
          response: botReply,
          imageData: imageResult.imageData,
          imageId: imageResult.imageId,
          conversationHistory: updatedHistory,
        });
      } catch (error) {
        console.error("Image generation failed:", error);
        botReply = "I'm sorry, I wasn't able to generate that image. Could you try a different description?";
      }
    } 
    // Check if the message is a request status check
    else if (userMessage.includes('request status') || userMessage.includes('check status')) {
      // Find pending requests for the user from the session
      if (!username) {
        botReply = "Please log in to check your request status.";
      } else {
        // Query the Message collection for pending requests
        const pendingRequests = await Message.find({
          'metadata.requester': username,
          status: { $in: ['pending', 'accepted', 'cancelled'] }
        }).sort({ createdAt: -1 }).limit(5);

        if (pendingRequests.length === 0) {
          botReply = "You don't have any recent access requests.";
        } else {
          // Format the requests status
          botReply = "Here are your recent requests:\n\n";
          pendingRequests.forEach(request => {
            const statusEmoji = {
              'pending': '⏳',
              'accepted': '✅',
              'cancelled': '❌'
            }[request.status];
            
            const pageName = request.metadata.pageName;
            const requestDate = new Date(request.createdAt).toLocaleDateString();
            
            botReply += `${statusEmoji} ${pageName} - ${request.status.toUpperCase()} (${requestDate})\n`;
            
            if (request.status === 'accepted') {
              const expiryDate = new Date(request.metadata.expiryDate).toLocaleDateString();
              botReply += `   Access expires on: ${expiryDate}\n`;
            }
          });
        }
      }
    } else if (userMessage.includes('hi') || userMessage.includes('hello')) {
      botReply = "Hi there! How can I assist you today?";
    } else if (userMessage.includes('help')) {
      botReply = `I can help you with:
1. Requesting access to pages
2. Checking your request status (just say "check status")
3. Generating images (say "generate image of..." or "draw...")
4. General assistance

What would you like help with?`;
    } else if (userMessage.includes('make a paragrap')) {
      botReply = `
        You have the following pending requests:

        1. Grant access to the **Dashboard Page**.
        2. Grant access to the **Admin Settings**.
        3. Grant access to the **User Analytics Page**.

        Please choose an option:
        - Type the number of the request you want to process (e.g., "1" for Dashboard Page).
        - Or type "Cancel" to dismiss all requests.
      `;
    } else if (["1", "2", "3"].includes(userMessage)) {
      const responses = {
        "1": "Access to the Dashboard Page has been granted.",
        "2": "Access to Admin Settings has been granted.",
        "3": "Access to the User Analytics Page has been granted.",
      };
      botReply = responses[userMessage];
    } else if (userMessage === "cancel") {
      botReply = "All pending requests have been dismissed.";
    } else {
      // Try using Gemini for a more intelligent response
      try {
        const model = gemini.getGenerativeModel({ model: "gemini-1.5-flash" });
        
        const result = await model.generateContent({
          contents: [
            {
              role: "user",
              parts: [
                { text: message }
              ]
            }
          ],
          generationConfig: {
            temperature: 0.5,
            maxOutputTokens: 1024,
          }
        });
        
        const aiResponse = result.response.text();
        if (aiResponse && aiResponse.trim()) {
          botReply = aiResponse;
        } else {
          // Default response for unrecognized input
          botReply = `You said: "${message}". If you need help, just ask!`;
        }
      } catch (error) {
        console.error('Error getting AI response:', error);
        // Fallback response
        botReply = `You said: "${message}". If you need help, just ask!`;
      }
    }

    // Optionally update conversation history
    const updatedHistory = [
      ...(conversationHistory || []),
      { text: message, sender: 'user' },
      { text: botReply, sender: 'gemini' },
    ];

    // Respond with the bot's reply and updated history
    res.json({
      response: botReply,
      conversationHistory: updatedHistory,
    });

  } catch (error) {
    console.error('Error in chatbox controller:', error);
    res.status(500).json({
      error: 'An error occurred while processing your message',
      details: error.message
    });
  }
};
  
export const getRequestStatus = async (req, res) => {
  try {
    const { username } = req.params;
    const updates = await Message.find({
      'metadata.requester': username,
      status: { $in: ['accepted', 'cancelled'] },
      'responseMetadata.notified': { $ne: true }
    });

    // Mark updates as notified
    await Message.updateMany(
      { _id: { $in: updates.map(u => u._id) } },
      { $set: { 'responseMetadata.notified': true } }
    );

    res.json({ success: true, updates });
  } catch (error) {
    console.error('Error fetching request status:', error);
    res.status(500).json({ success: false, error: error.message });
  }
};

export const handleStatusUpdate = async (req, res) => {
  try {
    const { userId, status, messageId, respondedBy } = req.body;
    
    // Get the socket ID for the specific user
    const socketId = userSockets.get(userId);
    
    if (socketId) {
      // Emit to specific user's room
      io.to(userId).emit('requestStatusUpdate', {
        userId,
        status,
        messageId,
        respondedBy
      });
    }
    
    // Update the message in database
    await Message.findByIdAndUpdate(messageId, {
      status,
      'responseMetadata.respondedBy': respondedBy,
      'responseMetadata.responseTime': new Date()
    });
    
    res.json({ success: true, message: 'Status update sent successfully' });
  } catch (error) {
    console.error('Error sending status update:', error);
    res.status(500).json({ success: false, error: error.message });
  }
};

  export const generateAccessRequestMessage = (username, name, department, pageName, details) => {
    const timestamp = new Date().toLocaleString();
    return `Access Request Details:
  - Username: ${username}
  - Full Name: ${name || 'N/A'}
  - Department: ${department}
  - Page Requested: ${pageName}
  - Request Time: ${timestamp}
  - Page URL: /${pageName.toLowerCase()}
  
  Please review this access request and either approve or deny it through the messaging system.`;
  };
  
  export const sendMessage = async (req, res) => {
    try {
      const { 
        requestType, 
        pageName, 
        name, 
        department, 
        username, 
        requestDetails 
      } = req.body;
  
      // Log the entire request body for debugging
      console.log('Received request body:', req.body);
  
      // Detailed validation with specific error messages
      const missingFields = [];
      if (!requestType) missingFields.push('requestType');
      if (!pageName) missingFields.push('pageName');
      if (!department) missingFields.push('department');
      if (!username) missingFields.push('username');
      if (!name) missingFields.push('name');
  
      if (missingFields.length > 0) {
        return res.status(400).json({ 
          success: false, 
          error: "Missing required fields",
          missingFields: missingFields
        });
      }
  
      // Ensure requestDetails is an object
      if (!requestDetails || typeof requestDetails !== 'object') {
        return res.status(400).json({
          success: false,
          error: "Invalid or missing requestDetails"
        });
      }
  
      // Generate message content
      const messageContent = generateAccessRequestMessage(
        username,
        name,
        department,
        pageName,
        requestDetails
      );
  
      const newMessage = new Message({
        content: messageContent,
        department: 'Administrative', // Explicitly set to Administrative
        targetRole: 'superadmin', // Ensure only superadmin can view
        status: 'pending',
        metadata: {
          requestType,
          pageName,
          requester: username,
          name: name,
          requestDetails: {
            ...requestDetails,
            requestTime: new Date()
          }
        }
      });
  
      await newMessage.save();
  
      res.json({ 
        success: true, 
        message: messageContent,
        messageId: newMessage._id 
      });
    } catch (error) {
      console.error("Error sending message:", error);
      res.status(500).json({ 
        success: false, 
        error: "Failed to process message",
        details: error.message 
      });
    }
  };
  
  export const getDepartmentMessages = async (req, res) => {
    try {
      const { department } = req.params;
      const { role } = req.query;
  
      console.log("Received request for messages:", { department, role });
  
      // Check if the user is a superadmin in the Administrative department
      if (department.toLowerCase() !== 'administrative' || role.toLowerCase() !== 'superadmin') {
        console.log("Authorization failed:", { department, role });
        return res.status(403).json({ 
          success: false, 
          error: "Unauthorized access" 
        });
      }
  
      const messages = await Message.find({ 
        department: 'Administrative', // Exact match for department
        targetRole: 'superadmin',
        status: 'pending'
      }).sort({ createdAt: -1 });
  
      console.log("Found messages:", messages);
  
      res.json({ 
        success: true, 
        messages 
      });
    } catch (error) {
      console.error("Error in getDepartmentMessages:", error);
      res.status(500).json({ 
        success: false, 
        error: "Failed to fetch messages" 
      });
    }
  };
  

  export const updateMessageStatus = async (req, res) => {
    try {
        const { id } = req.params;
        const { status, responderUsername } = req.body;

        console.log('Received update request:', { id, status, responderUsername });

        if (!id || !status || !responderUsername) {
            console.error('Missing required fields', { id, status, responderUsername });
            return res.status(400).json({ success: false, error: "Missing required fields" });
        }

        if (!['accepted', 'cancelled'].includes(status)) {
            console.error('Invalid status', { status });
            return res.status(400).json({ success: false, error: "Invalid status" });
        }

        // Find the request in the database
        const message = await Message.findById(id);
        if (!message) {
            console.error('Message not found', { id });
            return res.status(404).json({ success: false, error: "Message not found" });
        }

        // CRITICAL DEBUG LOGGING
        console.log('Message Metadata:', {
            requester: message.metadata?.requester,
            pageName: message.metadata?.pageName
        });

        // Update the request status
        message.status = status;
        message.responseMetadata = {
            respondedBy: responderUsername,
            responseTime: new Date()
        };

        await message.save();

        // Grant access if request was accepted
        if (status === "accepted") {
            try {
                const userId = message.metadata?.requester;
                if (!userId) {
                    throw new Error('No requester ID found in message metadata');
                }

                // Clean up pagePath - remove double slashes and ensure single leading slash
                const pagePath = message.metadata.pageName 
                    ? `/${message.metadata.pageName.toLowerCase().replace(/^\/+/, '')}` 
                    : null;

                if (!pagePath) {
                    throw new Error('No valid page path found');
                }

                console.log('Attempting to grant access:', { userId, pagePath });

                // Find user and update permissions
                const user = await User.findOne({ 
                    $or: [
                        { username: userId },
                        { _id: userId }
                    ]
                });

                if (!user) {
                    console.error('User not found', { 
                        userId, 
                        searchCriteria: ['username', 'id'] 
                    });
                    throw new Error(`User not found for ID: ${userId}`);
                }

                // Set up expiry date (24 hours from now)
                const now = new Date();
                const expiryDate = new Date();
                expiryDate.setDate(now.getDate() + 1);

                // Update user's permissions
                user.permissions = user.permissions || [];
                user.expiryMap = user.expiryMap || {};

                if (!user.permissions.includes(pagePath)) {
                    user.permissions.push(pagePath);
                }
                user.expiryMap[pagePath] = expiryDate;

                // Save the updated user
                await user.save();
                console.log(`Updated permissions for user ${userId}:`, {
                    permissions: user.permissions,
                    expiryMap: user.expiryMap
                });

                // Emit event via socket.io
                const io = req.app.get("io");
                if (io) {
                    io.emit("permissionUpdated", {
                        userId,
                        grantedBy: responderUsername,
                        name: user.name,
                        permissions: [pagePath]
                    });
                    console.log(`Sent real-time notification to ${userId}`);
                }
            } catch (accessError) {
                console.error("Detailed access granting error:", {
                    message: accessError.message,
                    stack: accessError.stack
                });
                return res.status(500).json({ 
                    success: false, 
                    error: "Failed to grant access",
                    details: accessError.message 
                });
            }
        }

        res.json({ 
            success: true, 
            message: `Request ${status} and permissions ${status === 'accepted' ? 'granted' : 'unchanged'}`, 
            data: message 
        });
    } catch (error) {
        console.error("Comprehensive error in updateMessageStatus:", {
            message: error.message,
            stack: error.stack,
            name: error.name
        });
        res.status(500).json({ 
            success: false, 
            error: "Failed to update request status",
            details: error.message 
        });
    }
};

export const getallmessage = async(req,res)=>{
  try {
      const messages = await Message.find();
      res.json({ success: true, messages });
  } catch (error) {
      console.error('Error fetching messages:', error);
      res.status(500).json({ success: false, error: 'Failed to fetch messages' });
  }
}


  export const createLog = async (user, action, description, route ) => {
      try {
          const newLog = new Log({
              username: user.username,
              name: user.name,
              department: user.department,
              role: user.role,
              action,
              description,
              route, // Ensure route is always provided
          });
          await newLog.save();
      } catch (error) {
          console.error('Error creating log:', error);
      }
  };
  
  

  const generateUsername = (role, name) => {
    const sanitizedName = name.toLowerCase().replace(/\s+/g, '');
    const random = Math.floor(100 + Math.random() * 900);
    return `${role}-${sanitizedName}${random}`;
};

export const registerUser = async (req, res) => {
    const { name, email, password, phoneNumber, role, adminUsername, department, address } = req.body;
    console.log("Received registration data:", req.body);
    
    // Validate input using Joi
    const schema = Joi.object({
        name: Joi.string().required(),
        email: Joi.string().email().required(),
        password: Joi.string()
            .min(8)
            .pattern(/[a-z]/, "lowercase")
            .pattern(/[A-Z]/, "uppercase")
            .pattern(/[0-9]/, "numbers")
            .pattern(/[@$!%*?&#]/, "special characters")
            .required(),
        phoneNumber: Joi.string().required(),
        role: Joi.string().valid("admin", "manager", "employee", "user", "staff", "superadmin", "technician").required(),
        adminUsername: Joi.string().when("role", { is: Joi.valid("admin", "manager", "employee"), then: Joi.required() }),
        department: Joi.string().valid("HR", "Core", "Logistics", "Finance", "Administrative").required(),
        address: Joi.string().optional()
    });
    
    const { error } = schema.validate({ 
        name, email, password, phoneNumber, role, adminUsername, department, address 
    });
    
    if (error) {
        return res.status(400).json({ error: error.details[0].message });
    }
    
    try {
        // Check for existing user in main User model
        const existingUser = await User.findOne({ email });
        if (existingUser) {
            return res.status(400).json({ error: "Email already exists" });
        }
        
        // Check for admin username if applicable
        if (["admin", "manager", "employee"].includes(role)) {
            const existingAdmin = await User.findOne({ username: adminUsername, role: "admin" });
            if (!existingAdmin) {
                return res.status(400).json({ error: "Invalid admin username" });
            }
        }
        
        // Generate username for main User model only
        const username = generateUsername(role, name);
        
        // Save user to the main User model
        const newUser = new User({
            name,
            email,
            password, // The pre-save hook will hash this
            phoneNumber,
            role,
            department,
            username
        });
        
        const savedUser = await newUser.save();
        console.log(`User saved to main User model: ${savedUser._id}`);
        
        // Now add the user to the appropriate department model
        let departmentUser;
        
        switch(department) {
            case 'Finance':
                departmentUser = new FinanceUser({
                    userNumber: '', // Left blank as requested
                    fullName: name,
                    email,
                    password: savedUser.password, // Already hashed from main model
                    role,
                    phone: phoneNumber,
                    address: address || '',
                    image: ''
                });
                break;
                
            case 'HR':
            case 'Core':
            case 'Logistics':
                // Extract first and last name
                const nameParts = name.split(' ');
                const firstname = nameParts[0];
                const lastname = nameParts.slice(1).join(' ');
                
                // Use the appropriate model based on department
                const DeptModel = department === 'HR' ? HRUser : 
                                  department === 'Core' ? CoreUser : LogisticsUser;
                
                departmentUser = new DeptModel({
                    userNumber: '', // Left blank as requested
                    firstname,
                    lastname,
                    email,
                    password: savedUser.password, // Already hashed from main model
                    role,
                    phone: phoneNumber,
                    address: address || '',
                    image: ''
                });
                break;
                
            case 'Administrative':
                departmentUser = new AdminUser({
                    userNumber: '', // Left blank as requested
                    fullName: name,
                    email,
                    password: savedUser.password, // Already hashed from main model
                    role,
                    phone: phoneNumber,
                    address: address || '',
                    image: ''
                });
                break;
                
            default:
                throw new Error(`Department model not found for ${department}`);
        }
        
        const savedDeptUser = await departmentUser.save();
        console.log(`User added to ${department} department successfully. ID: ${savedDeptUser._id}`);
        
        // Prepare response (removing sensitive data)
        const userResponse = {
            _id: savedUser._id,
            name: savedUser.name,
            email: savedUser.email,
            role: savedUser.role,
            phoneNumber: savedUser.phoneNumber,
            department: savedUser.department,
            username: savedUser.username,
            departmentUserId: savedDeptUser._id
        };
        
        res.status(201).json({
            user: userResponse,
            message: `User successfully registered and added to ${department} department`
        });
        
    } catch (error) {
        console.error("Registration error:", error.message);
        // If there's a database error like duplicate key, provide more specific error
        if (error.code === 11000) {
            return res.status(400).json({ 
                message: "Registration failed", 
                error: "Duplicate email or username" 
            });
        }
        res.status(500).json({ 
            message: "Server error. Please try again later.", 
            error: error.message 
        });
    }
};

